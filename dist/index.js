"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("node:path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const glob_1 = require("glob");
const node_html_parser_1 = require("node-html-parser");
const defaultConfig = {
    inputDir: process.env.SVG_INPUT_DIR || 'svg-icons',
    outputDir: process.env.SVG_OUTPUT_DIR || 'public/images/icons',
    typesDir: process.env.SVG_TYPES_DIR || 'public/images/icons',
    spriteFilename: process.env.SVG_SPRITE_FILENAME || 'sprite.svg',
    typeFilename: process.env.SVG_TYPE_FILENAME || 'name.d.ts',
    verbose: process.env.SVG_VERBOSE === 'true' ? true : false,
    generateReadme: process.env.SVG_GENERATE_README === 'true' ? true : false
};
async function main(userConfig = {}) {
    const config = { ...defaultConfig, ...userConfig };
    const cwd = process.cwd();
    const inputDir = path.join(cwd, config.inputDir);
    const inputDirRelative = path.relative(cwd, inputDir);
    const outputDir = path.join(cwd, config.outputDir);
    const typesDir = path.join(cwd, config.typesDir);
    await fs_extra_1.default.ensureDir(outputDir);
    const files = glob_1.glob
        .sync('**/*.svg', {
        cwd: inputDir,
    })
        .sort((a, b) => a.localeCompare(b));
    const logVerbose = config.verbose ? console.log : () => { };
    if (files.length === 0) {
        console.log(`No SVG files found in ${inputDirRelative}`);
    }
    else {
        await generateIconFiles(files, {
            inputDir,
            outputDir,
            typesDir,
            spriteFilename: config.spriteFilename,
            typeFilename: config.typeFilename,
            generateReadme: config.generateReadme,
            logVerbose,
        });
    }
    async function generateIconFiles(files, options) {
        const { inputDir, outputDir, typesDir, spriteFilename, typeFilename, generateReadme, logVerbose } = options;
        const spriteFilepath = path.join(outputDir, spriteFilename);
        const typeOutputFilepath = path.join(typesDir, typeFilename);
        const currentSprite = await fs_extra_1.default
            .readFile(spriteFilepath, 'utf8')
            .catch(() => '');
        const currentTypes = await fs_extra_1.default
            .readFile(typeOutputFilepath, 'utf8')
            .catch(() => '');
        const iconNames = files.map((file) => iconName(file));
        const spriteUpToDate = iconNames.every((name) => currentSprite.includes(`id=${name}`));
        const typesUpToDate = iconNames.every((name) => currentTypes.includes(`"${name}"`));
        if (spriteUpToDate && typesUpToDate) {
            logVerbose(`Icons are up to date`);
            return;
        }
        logVerbose(`Generating sprite for ${inputDirRelative}`);
        const spriteChanged = await generateSvgSprite({
            files,
            inputDir,
            outputPath: spriteFilepath,
        });
        for (const file of files) {
            logVerbose('âœ…', file);
        }
        logVerbose(`Saved to ${path.relative(cwd, spriteFilepath)}`);
        const stringifiedIconNames = iconNames.map((name) => JSON.stringify(name));
        const typeOutputContent = `// This file is generated by npm run icons

export type IconName =
\t| ${stringifiedIconNames.join('\n\t| ')};
`;
        const typesChanged = await writeIfChanged(typeOutputFilepath, typeOutputContent);
        logVerbose(`Manifest saved to ${path.relative(cwd, typeOutputFilepath)}`);
        const readmeChanged = generateReadme && await writeIfChanged(path.join(outputDir, 'README.md'), `# Icons

This directory contains SVG icons that are used by the app.

Everything in this directory is generated by \`npm run icons\`.
`);
        if (spriteChanged || typesChanged || readmeChanged) {
            console.log(`Generated ${files.length} icons`);
        }
    }
    function iconName(file) {
        return file.replace(/\.svg$/, '');
    }
    /**
     * Creates a single SVG file that contains all the icons
     */
    async function generateSvgSprite({ files, inputDir, outputPath, }) {
        // Each SVG becomes a symbol and we wrap them all in a single SVG
        const symbols = await Promise.all(files.map(async (file) => {
            const input = await fs_extra_1.default.readFile(path.join(inputDir, file), 'utf8');
            const root = (0, node_html_parser_1.parse)(input);
            const svg = root.querySelector('svg');
            if (!svg)
                throw new Error('No SVG element found');
            svg.tagName = 'symbol';
            svg.setAttribute('id', iconName(file));
            svg.removeAttribute('xmlns');
            svg.removeAttribute('xmlns:xlink');
            svg.removeAttribute('version');
            svg.removeAttribute('width');
            svg.removeAttribute('height');
            svg.removeAttribute('fill');
            // loop over paths and remove the `fill` setAttribute
            // this allows us to set the svg fill with css
            const paths = svg.querySelectorAll('path');
            for (const path of paths) {
                path.removeAttribute('fill');
            }
            return svg.toString().trim();
        }));
        const output = [
            `<?xml version="1.0" encoding="UTF-8"?>`,
            `<!-- This file is generated by npm run icons -->`,
            `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
            `<defs>`, // for semantics: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs
            ...symbols,
            `</defs>`,
            `</svg>`,
            '', // trailing newline
        ].join('\n');
        return writeIfChanged(outputPath, output);
    }
    async function writeIfChanged(filepath, newContent) {
        const currentContent = await fs_extra_1.default
            .readFile(filepath, 'utf8')
            .catch(() => '');
        if (currentContent === newContent)
            return false;
        await fs_extra_1.default.writeFile(filepath, newContent, 'utf8');
        return true;
    }
}
exports.default = main;
