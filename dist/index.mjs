#!/usr/bin/env node
import * as path from 'node:path';
import fsExtra from 'fs-extra';
import { glob } from 'glob';
import { parse } from 'node-html-parser';
import dotenv from 'dotenv';
import readline from 'node:readline/promises';
import chalk from 'chalk';
// Update dotenv config to look in the current working directory
dotenv.config({ path: path.join(process.cwd(), '.env') });
const defaultConfig = {
    inputDir: process.env.SVG_INPUT_DIR || 'svg-icons',
    outputDir: process.env.SVG_OUTPUT_DIR || 'public/images/icons',
    typesDir: process.env.SVG_TYPES_DIR || 'public/images/icons',
    spriteFilename: process.env.SVG_SPRITE_FILENAME || 'sprite.svg',
    typeFilename: process.env.SVG_TYPE_FILENAME || 'name.d.ts',
    verbose: process.env.SVG_VERBOSE === 'true' ? true : false,
    generateReadme: process.env.SVG_GENERATE_README === 'true' ? true : false
};
const frameworkConfigs = {
    'next-pages': {
        inputDir: './other/svg-icons',
        outputDir: './public/images/icons',
        typesDir: './src/types/icons',
        typeFilename: 'icons.d.ts'
    },
    'next-app': {
        inputDir: './src/other/svg-icons',
        outputDir: './public/images/icons',
        typesDir: './src/types/icons',
        typeFilename: 'icons.d.ts'
    },
    remix: {
        inputDir: './other/svg-icons',
        outputDir: './public/images/icons',
        typesDir: './app/types/icons',
        typeFilename: 'icons.d.ts'
    },
    sveltekit: {
        inputDir: './other/svg-icons',
        outputDir: './static/images/icons',
        typesDir: './src',
        typeFilename: 'icons.d.ts'
    },
    astro: {
        inputDir: './other/svg-icons',
        outputDir: './public/images/icons',
        typesDir: './src',
        typeFilename: 'icons.d.ts'
    }
};
async function main(userConfig = {}) {
    const config = { ...defaultConfig, ...userConfig };
    const cwd = process.cwd();
    const inputDir = path.join(cwd, config.inputDir);
    console.log('üîç Looking for SVGs in:', inputDir);
    const inputDirRelative = path.relative(cwd, inputDir);
    const outputDir = path.join(cwd, config.outputDir);
    const typesDir = path.join(cwd, config.typesDir);
    await fsExtra.ensureDir(inputDir);
    await fsExtra.ensureDir(outputDir);
    await fsExtra.ensureDir(typesDir);
    const files = glob
        .sync('**/*.svg', {
        cwd: inputDir,
    })
        .sort((a, b) => a.localeCompare(b));
    console.log('Found SVG files:', files);
    const logVerbose = config.verbose ? console.log : () => { };
    if (files.length === 0) {
        console.log(`No SVG files found in ${inputDirRelative}`);
    }
    else {
        await generateIconFiles(files, {
            inputDir,
            outputDir,
            typesDir,
            spriteFilename: config.spriteFilename,
            typeFilename: config.typeFilename,
            generateReadme: config.generateReadme,
            logVerbose,
        });
    }
    async function generateIconFiles(files, options) {
        const { inputDir, outputDir, typesDir, spriteFilename, typeFilename, generateReadme, logVerbose } = options;
        const spriteFilepath = path.join(outputDir, spriteFilename);
        const typeOutputFilepath = path.join(typesDir, typeFilename);
        const currentSprite = await fsExtra
            .readFile(spriteFilepath, 'utf8')
            .catch(() => '');
        const currentTypes = await fsExtra
            .readFile(typeOutputFilepath, 'utf8')
            .catch(() => '');
        const iconNames = files.map((file) => iconName(file));
        const spriteUpToDate = iconNames.every((name) => currentSprite.includes(`id=${name}`));
        const typesUpToDate = iconNames.every((name) => currentTypes.includes(`"${name}"`));
        if (spriteUpToDate && typesUpToDate) {
            logVerbose(`Icons are up to date`);
            return;
        }
        logVerbose(`Generating sprite for ${inputDirRelative}`);
        const spriteChanged = await generateSvgSprite({
            files,
            inputDir,
            outputPath: spriteFilepath,
        });
        for (const file of files) {
            logVerbose('‚úÖ', file);
        }
        logVerbose(`Saved to ${path.relative(cwd, spriteFilepath)}`);
        const stringifiedIconNames = iconNames.map((name) => JSON.stringify(name));
        const typeOutputContent = `// This file is generated by npm run build:icons

export type IconName =
\t| ${stringifiedIconNames.join('\n\t| ')};
`;
        const typesChanged = await writeIfChanged(typeOutputFilepath, typeOutputContent);
        logVerbose(`Manifest saved to ${path.relative(cwd, typeOutputFilepath)}`);
        const readmeChanged = generateReadme && await writeIfChanged(path.join(outputDir, 'README.md'), `# Icons

This directory contains SVG icons that are used by the app.

Everything in this directory is generated by \`npm run build:icons\`.
`);
        if (spriteChanged || typesChanged || readmeChanged) {
            console.log(`Generated ${files.length} icons`);
        }
    }
    function iconName(file) {
        return file.replace(/\.svg$/, '');
    }
    /**
     * Creates a single SVG file that contains all the icons
     */
    async function generateSvgSprite({ files, inputDir, outputPath, }) {
        // Each SVG becomes a symbol and we wrap them all in a single SVG
        const symbols = await Promise.all(files.map(async (file) => {
            const input = await fsExtra.readFile(path.join(inputDir, file), 'utf8');
            const root = parse(input);
            const svg = root.querySelector('svg');
            if (!svg)
                throw new Error('No SVG element found');
            svg.tagName = 'symbol';
            svg.setAttribute('id', iconName(file));
            svg.removeAttribute('xmlns');
            svg.removeAttribute('xmlns:xlink');
            svg.removeAttribute('version');
            svg.removeAttribute('width');
            svg.removeAttribute('height');
            svg.removeAttribute('fill');
            // loop over paths and remove the `fill` setAttribute
            // this allows us to set the svg fill with css
            const paths = svg.querySelectorAll('path');
            for (const path of paths) {
                path.removeAttribute('fill');
            }
            return svg.toString().trim();
        }));
        const output = [
            `<?xml version="1.0" encoding="UTF-8"?>`,
            `<!-- This file is generated by npm run build:icons -->`,
            `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
            `<defs>`, // for semantics: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs
            ...symbols,
            `</defs>`,
            `</svg>`,
            '', // trailing newline
        ].join('\n');
        return writeIfChanged(outputPath, output);
    }
    async function writeIfChanged(filepath, newContent) {
        const currentContent = await fsExtra
            .readFile(filepath, 'utf8')
            .catch(() => '');
        if (currentContent === newContent)
            return false;
        await fsExtra.writeFile(filepath, newContent, 'utf8');
        return true;
    }
}
async function setup() {
    const cwd = process.cwd();
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    console.log(chalk.yellow('üçã Setting up SVG Sprite Builder configuration...\n'));
    // Ask for framework first
    console.log(chalk.cyan('Available frameworks:'));
    console.log(chalk.gray('  1. Next.js (Pages Router)'));
    console.log(chalk.gray('  2. Next.js (App Router)'));
    console.log(chalk.gray('  3. Remix'));
    console.log(chalk.gray('  4. SvelteKit'));
    console.log(chalk.gray('  5. Astro'));
    console.log(chalk.gray('  0. Custom configuration'));
    console.log('');
    const frameworkChoice = await rl.question(chalk.cyan('üçã Select your framework (0-5): '));
    console.log('');
    // Create a copy of the base config
    let configDefaults = { ...defaultConfig };
    switch (frameworkChoice) {
        case '1':
            configDefaults = { ...configDefaults, ...frameworkConfigs['next-pages'] };
            break;
        case '2':
            configDefaults = { ...configDefaults, ...frameworkConfigs['next-app'] };
            break;
        case '3':
            configDefaults = { ...configDefaults, ...frameworkConfigs['remix'] };
            break;
        case '4':
            configDefaults = { ...configDefaults, ...frameworkConfigs['sveltekit'] };
            break;
        case '5':
            configDefaults = { ...configDefaults, ...frameworkConfigs['astro'] };
            break;
        case '0':
        default:
            // Use existing defaults
            break;
    }
    // Rest of the setup using the selected configDefaults...
    const config = {
        inputDir: await rl.question(chalk.cyan(`üçã Input directory for SVG files ${chalk.gray(`(default: ${configDefaults.inputDir})`)}: `)) || configDefaults.inputDir,
        outputDir: await rl.question(chalk.cyan(`üçã Output directory for sprite ${chalk.gray(`(default: ${configDefaults.outputDir})`)}: `)) || configDefaults.outputDir,
        typesDir: await rl.question(chalk.cyan(`üçã Directory for TypeScript types ${chalk.gray(`(default: ${configDefaults.typesDir})`)}: `)) || configDefaults.typesDir,
        spriteFilename: await rl.question(chalk.cyan(`üçã Sprite filename ${chalk.gray(`(default: ${configDefaults.spriteFilename})`)}: `)) || configDefaults.spriteFilename,
        typeFilename: await rl.question(chalk.cyan(`üçã Type definition filename ${chalk.gray(`(default: ${configDefaults.typeFilename})`)}: `)) || configDefaults.typeFilename,
        verbose: (await rl.question(chalk.cyan(`üçã Enable verbose logging? ${chalk.gray('(y/N)')}: `))).toLowerCase() === 'y',
        generateReadme: (await rl.question(chalk.cyan(`üçã Generate README? ${chalk.gray('(Y/n)')}: `))).toLowerCase() !== 'n'
    };
    // Handle package.json
    const pkgPath = path.join(cwd, 'package.json');
    let pkg = {};
    try {
        pkg = JSON.parse(await fsExtra.readFile(pkgPath, 'utf8'));
    }
    catch (error) {
        console.log('‚ö†Ô∏è  No package.json found');
        process.exit(1);
    }
    pkg.scripts = pkg.scripts || {};
    let shouldUpdatePackageJson = !pkg.scripts['build:icons'];
    if (pkg.scripts['build:icons']) {
        const overwrite = await rl.question(chalk.red('üò±  build:icons script already exists. Overwrite? ') + chalk.gray('(y/N): '));
        shouldUpdatePackageJson = overwrite.toLowerCase() === 'y';
    }
    // Check if .env exists and get overwrite permission
    const envPath = path.join(cwd, '.env');
    let shouldUpdateEnv = !await fsExtra.pathExists(envPath);
    if (await fsExtra.pathExists(envPath)) {
        const overwrite = await rl.question(chalk.red('üò±  .env file already exists. Overwrite? ') + chalk.gray('(y/N): '));
        shouldUpdateEnv = overwrite.toLowerCase() === 'y';
    }
    // Now we can safely close readline
    rl.close();
    // Create directories
    await fsExtra.ensureDir(path.join(cwd, config.inputDir));
    await fsExtra.ensureDir(path.join(cwd, config.outputDir));
    await fsExtra.ensureDir(path.join(cwd, config.typesDir));
    // Update package.json if needed
    if (shouldUpdatePackageJson) {
        pkg.scripts['build:icons'] = 'lemon-lime-svgs';
        await fsExtra.writeFile(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
        console.log(chalk.green('‚úÖ Added build:icons script to package.json'));
    }
    else {
        console.log('');
        console.log('Skipping script addition');
        console.log('');
    }
    // Update .env if needed
    if (shouldUpdateEnv) {
        const envContent = `SVG_INPUT_DIR="${config.inputDir}"
SVG_OUTPUT_DIR="${config.outputDir}"
SVG_TYPES_DIR="${config.typesDir}"
SVG_SPRITE_FILENAME="${config.spriteFilename}"
SVG_TYPE_FILENAME="${config.typeFilename}"
SVG_VERBOSE=${config.verbose}
SVG_GENERATE_README=${config.generateReadme}
`;
        await fsExtra.writeFile(envPath, envContent);
        console.log(chalk.green('\n‚úÖ Created .env file'));
        console.log(chalk.yellow('üìù Configuration Preview:'));
        console.log(chalk.gray(envContent));
    }
    else {
        console.log('');
        console.log('‚ùå Setup cancelled');
        console.log('');
        process.exit(0);
    }
    console.log(chalk.green('‚úÖ Created required directories'));
    console.log(chalk.green(`üéâ Setup complete! You can now add SVG files to ${chalk.cyan(config.inputDir)}/\n`));
}
export default main;
export { setup };
